{"name":"Piautomator","tagline":"Simple Python lib that allows you to read values from sensors etc. on the Pi and then trigger receivers into certain states. Or any other automation.","body":"PiAutomator\r\n===========\r\n\r\nSimple Python lib that allows you to read values from sensors etc. on the Pi and then trigger receivers into certain states.\r\n\r\nCurrently using this with a DHT22 sensor wired and a wired switch (KlikAanKlikUit) \r\nto switch the fan when it gets too humid in the bathroom\r\n\r\nThe setup is created in such a way that it should be easy enough to add more and different types of sensors and the\r\ntypes of receivers should also be able to get a bit more variation, although I'll probably stick with kaku for now.\r\n\r\nRequired libs\r\n-------------\r\nA couple of python modules were used in the writing of this software. You should install then too:\r\n\r\n* PyYAML\r\n* pyparsing\r\n* schedule -> Actually is included for now, but only until I get a pull request merged\r\n* graphitesend -> If you want to enable graphite data sending\r\n* wiringpi2 -> If you're using the direct KAKU controller\r\n* pyserial -> If you want to use the LLAP receivers\r\n\r\nto get them all:\r\n\r\n```\r\nsudo pip install PyYAML pyparsing schedule graphitesend  pyserial wiringpi2\r\n```\r\n\r\nNote that wiringpi only works on raspberry pi and is only needed for pin access. So if you have no pins, don't\r\ninstall wiringpi2:\r\n\r\n```\r\nsudo pip install PyYAML pyparsing schedule graphitesend  pyserial\r\n```\r\n\r\nRules\r\n-----\r\nRules are used to make stuff happen in PiAutomator. There are two kinds of rules currently supported\r\n\r\n1. Schedule rules\r\n2. Conditional rules\r\n\r\n### Schedule rules\r\nSchedule rules make something happen on set times during the day/week/hour\r\n\r\nbasic format is:\r\n```\r\nevery <schedule> <action>\r\n```\r\n\r\n#### singular rules:\r\n\r\n```\r\nevery <unit> <at optional_time> <verb> <receiver> <state>\r\n\r\nunit: day hour second week sunday weekday weekendday\r\noptional_time: of the format 'at 10:30' or 'at :30' , only works for day/hour/weekday/weekenday\r\nverb: any word that makes your text look nice :) -> In the future some receivers might use this for more specificity\r\nreceiver: The name of any receiver to handle the scheduled event\r\nstate: The state to send to the receiver\r\n\r\nNote that weekday matches on monday, tuesday, wednesday, thursday, friday so a rule with this unit will fire on all\r\nthose days\r\nNote that weekendday matches on satureday, sunday so a rule with this unit will fire on all\r\nthose days\r\n\r\nExample:\r\nevery day turn lights on\r\nevery weekday at 10:30 turn lights on\r\n```\r\n\r\n#### plural rules\r\nlike singular but with:\r\n\r\n```\r\nevery <interval> <unit> <at optional_time> <verb> <receiver> <state>\r\n\r\ninterval: the interval to set\r\nunit: days hours seconds weeks\r\n\r\nExample\r\nevery 2 days turn lights on\r\nevery 2 days at 10:30 turn lights on\r\n```\r\n\r\n#### day rules\r\nallows firing on specific days of the week\r\n\r\n```\r\nevery <day(s)> <at optional_time> <verb> <receiver> <state>\r\n\r\nday(s): monday tuesday wednesday thursday friday saturday sunday\r\n        -> Allows for multiple days by connecting them with the 'and' keyword\r\n\r\nexample\r\nevery monday turn lights on\r\nevery monday at 10:30 turn lights on\r\nevery monday and tuesday and friday at 10:30 turn lights on\r\n```\r\n\r\n#### actions\r\nIn the examples above only a single action was performed every time a schedule matched. You can\r\nexecute multiple actions on a single schedule simply by defining more then one separated by 'and'\r\n\r\n```\r\nevery day at 8:00 turn lights on and send notification \"wake up!\"\r\n```\r\n\r\n### Conditional rules\r\nConditional rules fire based on certain conditions being met. All conditional rules operate on the AutomationContext\r\nwhich stores information about input states, rule states and receiver states. A rule condition can operate on all these.\r\nwhen matching, a conditional rule will fire the associated actions (same format as with scheduled rules) once. As long\r\nas the rule matched and keeps matching, it will only fire once (to prevent event storms)\r\n\r\nFormat:\r\n\r\n```\r\nwhen <value_path> is <operator> <value> then <action>\r\n\r\nvalue_path: a path to a value in the context\r\noperator: an operator on the value. Currently supported less than, greater than, equal to\r\nvalue: the value to compare. Casting may occur depending on the operator used\r\n\r\nexample\r\nwhen bathroom.humidity is greater than 60 then turn homefan on\r\n```\r\n\r\n#### value paths\r\nEvery input, rule and receiver in PiAutomator reports to the AutomationContext with values. If values change, a\r\nreevaluation of all conditional rules is triggered.\r\n\r\nvalue paths are nested name spaces with '.' separators. The context supports the following top level namespaces\r\nto make sure there are no collisions:\r\n\r\n- input\r\n- rule\r\n- receiver\r\n\r\nwhen writing a rule with a value path, the context will always first try to find the value using the exact supplied path\r\nwhen that cannot be found, it will try to find it in one of the predefined name spaces. You can look in to the dumped\r\nstate from the program if you're unsure about the path.\r\n\r\nExample:\r\n```\r\nwhen bathroom.humidity is less than 50 then turn homefan off\r\n```\r\n\r\nIn this case _bathroom.humidity_ is the path. When the rule matches, it will first look in the context for the exact\r\nvalue, afterwards it will also look for _input.bathroom.humidity_ and _rule.bathroom.humidity_ etc. until it finds\r\nsomething or it's options are exhausted.\r\n\r\n\r\nGraphite\r\n--------\r\nAutomatically sends collected sensor data to Graphite so you can keep an eye on your data.\r\nI used https://github.com/ghoulmann/rpi-graphite/blob/master/rpi-graphite.sh to quickly get graphite on the pi.\r\n\r\nGeneral Concepts\r\n----------------\r\n\r\nConfigures a set of rules that\r\n\r\n1. Take input from configured  receivers (like the DHT22)\r\n2. Take a fixed schedule\r\n\r\nand then execute (a series of) actions when input meets criteria.\r\n\r\nAn example of a rule could be:\r\n\r\n- when kitchen.temperature is greater than 25 then turn airconditioning on\r\n- every day at 20:00 turn outsidelights on\r\n\r\ntake a look at the included config-example.yaml on what is possible.\r\n\r\nTo get started:\r\n\r\n1. Install the required python libs.\r\n2. Create a config.yaml in conf/ with your settings\r\n3. run bin/bin/start-automator.py\r\n\r\n\r\npilight\r\n-------\r\nPiAutomator supports adding pilight as both inputs and receivers. pilight can read the DHT22 all by itself, should you not want to, you can config it directly.\r\n\r\nexample of pilight output:\r\n\r\n```\r\n  outsidelights:\r\n    translate-up-down: true # If using old style KAKY will translate rule action on/off to receiver up/down\r\n    type: PiLight\r\n    location: frontgarden  # Location from pilight config\r\n    device: lights  # device from pilight config\r\n```\r\n\r\nexample of specific pilight input:\r\n```\r\n   bathroom:\r\n     type: PiLight\r\n     location: bathroom  # location from pilight config\r\n     device: h_t_sensor  # device from pilight config\r\n     scale: 0.1  # Optional scale you can add to receivers returning numbers (works for all receivers)\r\n     \r\n   # corresponding rule\r\n   - when bathroom.humidity is greater than 70 turn homefan on\r\n```\r\n\r\nyou van also add all pilight input to the mix:\r\n```\r\n   all-pilight:\r\n     type: PiLight\r\n     location: all\r\n     device: all\r\n   \r\n   # corresponding rule\r\n   # - when pilight.<location>.<device>.<value> is equal to on\r\n   - when pilight.livingroom.christmastree.state is equal to 'up' then turn music on\r\n```\r\n\r\nDoing this will make all pilight values available for your rules to play with. Specific inputs take precedence over the all, so you can still have individual ones where you think it needed.\r\n\r\nIf you're unsure about what keys to use, the automator dumps it's state when you stop it. So have a look at the input section there.\r\n\r\nhttp://www.pilight.org/\r\n\r\nLLAP\r\n----\r\n\r\nPiAutomator support reading (and only readying currently) sensor data from LLAP compatible serial input devices. This is mainly usefull for remote sensors setting up a wireless network.\r\n\r\n- Basically, setup your Pi with a wireless receiver of somekind, I use the slice of radio (http://shop.ciseco.co.uk/slice-of-radio-wireless-rf-transciever-for-the-raspberry-pi/)\r\n- Use other devices to transmit on the correct frequency (for instance using something like http://shop.ciseco.co.uk/xrf-wireless-rf-radio-uart-rs232-serial-data-module-xbee-shape-arduino-pic-etc/)\r\n\r\nAnd set the remote up to send LLAP compatible data.\r\n- http://openmicros.org/index.php/articles/85-llap-lightweight-local-automation-protocol/101-llap-starter\r\n- http://openmicros.org/index.php/articles/85-llap-lightweight-local-automation-protocol/112-llap\r\n- Example: http://www.seanlandsman.com/2013/02/the-raspberry-pi-and-wireless-rf-xrf.html\r\n\r\nthen add a LLAP receiver per device you have installed:\r\n```\r\n  outside1:\r\n    type: LLAP\r\n    device-id: AA\r\n```\r\n\r\nthe receiver will automatically recognize and publish values for your rules to use. Currently supported are the following LLAP standard metrics:\r\n```\r\n    LLAP Command        Reported as         Data type/value\r\n    BATTLOW             lowbattery          True             -> Turns on low battery state\r\n    BATT                batterylevel        float\r\n    STARTED             lowbattery          False            -> Low battery is turned off when STARTED is received. If there is still lowbattery, you will get the BATTLOW again\r\n    LVAL                lightlevel          float\r\n    TEMP                temperature         float\r\n    TMPA                temperature         float\r\n    ANA                 analog              int\r\n    BUTTON              button              str              -> Unsure about this one, I don't have it and the docs are a bit unclear to me.\r\n```\r\n\r\nSo for instance based on above config an appropriate rule would be:\r\n```\r\n  - when outside1.lightlevel is less than 40 then tun outsidelights on\r\n```\r\n\r\n\r\nDHT22 - Direct\r\n--------------\r\n*NOTE:* You don't have to do anything here if you're not using the direct access DHT sensor receiver\r\n\r\ninstall bcm2835 library: http://www.airspayce.com/mikem/bcm2835/\r\n\r\nTo read the DHT22 sensor directly, this wonderfull piece of software was used:\r\n\r\nhttps://github.com/adafruit/Adafruit-Raspberry-Pi-Python-Code/tree/master/Adafruit_DHT_Driver_Python\r\n\r\nthe python lib is included in this release\r\n\r\nPlease note the following notice about that library:\r\n\r\nCopyright (c) 2012-2013 Limor Fried, Kevin Townsend and Mikey Sklar for Adafruit Industries. All rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\nStubs\r\n-----\r\nThe project contains a couple of stubs to allow for development/testing on other machines than the pi\r\n\r\nSpecifically:\r\n\r\n* /stubs/wiringpi2.py\r\n    basically noops all used wiringpi2 methods. Needed in order to run the python version of the KlikAanKlikUitReceivef\r\n* /stubs/dhtreader.py\r\n    For the DHT22 input. Returns random numbers between 10 and 25 for temperature and random numbers between 45 and 95 for humidity (full ints)\r\n\r\nLegal\r\n-----\r\nDistrubuted under Apache 2.0 license (see LICENSE.txt)\r\n","google":"UA-46698701-1","note":"Don't delete this file! It's used internally to help with page regeneration."}